UNIT  EqnTPU ;(**********************************************)INTERFACEtype    element = string ;    pointer = ^node ;    node = record 	      value: element ; 	      next: pointer 	      end ;    stack = record	      top: pointer ;	      size: integer ;	      end ;var   continue : char ;   mem_count : integer ;procedure get_node( var P: pointer );procedure return_node(var P: pointer) ;procedure create_stack(var S:stack);procedure destroy(var S: stack);procedure write_stack(var S: stack);function top(s:stack): element ;procedure pop(var S:stack);procedure push(E: element; var S: stack) ;procedure pull(var V: element; var S: stack) ;function Priority(I: element): real ;function power(base, realexpt: real): real ;function Eval(L, R: element; OP: char): element ;procedure get_X(var source, X: element) ;procedure error_msg ;(**************************************************)IMPLEMENTATIONprocedure get_node(var P: pointer);BEGIN     mem_count := mem_count + 1 ;     new(P)END ;procedure return_node(var P: pointer) ;BEGIN     mem_count := mem_count - 1 ;     P^.value := 'I am free' ;     P^.next := nil ;     dispose(P)END ;procedure create_stack(var S: stack) ;BEGIN     S.top := nil ;     S.size := 0 ;END; {proc create_stack}procedure destroy(var S: stack) ;var   temp : stack ;BEGIN     if (S.top <> Nil) then       BEGIN       temp := S ; {parameter is a stack so need a temporary stack to pass}       temp.top := temp.top^.next ;       destroy(temp) ;       return_node(S.top) ;       S.size := (S.size - 1)       END {if}END; {proc destroy}procedure write_stack(var S: stack);var   p: pointer ;BEGIN     if (S.size = 0) then       writeln('Empty stack.')     else         BEGIN  	 p := S.top ;  	 while p <> nil do  	    BEGIN  	    write( ' ', p^.value:5 ) ;  	    p := p^.next  	    END; {while}	 writeln	 END; {else}END; {proc write_stack}function top(S:stack): element ;BEGIN     { write('Topping: ');  write_stack(S);{DEBUG}     if (S.size <= 0) then       BEGIN       writeln('Top Error: Stack is already empty.');       error_msg ;       END {if}     else	 top := S.top^.value ;END; {fxn top}procedure pop(var S: stack) ;var   p: pointer ;BEGIN     if (S.size > 0) then       BEGIN       p := S.top ;       S.top := S.top^.next ;       return_node(p) ;       S.size := (S.size - 1)       END {if}     else	 BEGIN	 writeln('Pop Error: stack is already empty.') ;	 error_msg ;	 END; {else}END; {proc pop}procedure push(E: element; var S: stack) ;var   p: pointer ;BEGIN     get_node(p) ;     p^.value := E ;     p^.next := S.top ;     S.top := p ;     S.size := (S.size + 1) ;END; {proc push}procedure pull(var V: element; var S: stack) ;BEGIN     { write('Pulling: ');  write_stack(S) ;{DEBUG}     if (S.size > 0) then       BEGIN       V := S.top^.value ;       pop(S) ;       END {if}     else	 BEGIN	 writeln('Pull Error: stack is already empty.') ;	 error_msg ;	 END {else}END; {proc pull}function Priority(I: element): real ;BEGIN     if I = '^' then       Priority := 3     else if ((I = '*') or (I = '/')) then	 Priority := 2     else if ((I = '+') or (I = '-')) then	 Priority := 1     else	 Priority := 0END; {fxn Priority}function power(base, realexpt: real): real ;var   temp : real ;   expt : integer ;BEGIN     expt := Round(realexpt) ;     if expt = 0 then       power := 1     else if (expt mod 2) = 0 then            BEGIN  	    temp := power(base, expt div 2) ;  	    power := (temp * temp)  	    END {if}  	  else  	      BEGIN     	      temp := power(base, expt div 2) ;     	      power := (temp * temp * base)     	      END {else}END; {fxn power}function Eval(L, R: element; OP: char): element ;var   left, right, tot : real ;   errorcode : integer ;   temp : element ;BEGIN     Val(L, left, errorcode) ;     Val(R, right, errorcode) ;     case OP of        '+' :  tot := left + right ;	'-' :  tot := left - right ;        '^' :  tot := power(left, right) ;	'*' :  tot := left * right ;	'/' :  tot := left / right ;	else	    BEGIN	    writeln('Eval Error: improper operator: ', OP) ;	    error_msg ;	    END {else}	END; {case}     Str(tot:7:2 , temp) ;     Eval := tempEND; {fxn Eval}procedure get_X(var source, X: element) ;var   point, numeric : boolean ;   Y: element ;BEGIN     numeric := false ;     point := false ;     X := copy(source, 1, 1) ;     delete(source, 1, 1) ;     while (X = ' ') do	BEGIN	X := copy(source, 1, 1) ;	delete(source, 1, 1)	END ;     if ((X >= '0') and (X <= '9')) then       numeric := true ;     while numeric do	BEGIN	Y := copy(source, 1, 1) ;	if ((Y >= '0') and (Y <= '9')) then	  BEGIN	  X := concat(X, Y) ;	  delete(source, 1, 1)	  END {if}	else if ((Y = '.') and (not point)) then	    BEGIN	    X := concat(X, Y) ;	    point := true ;	    delete(source, 1, 1) ;	    END {elsif}	else if (Y = ' ') then	       delete(source, 1, 1)	     else		 numeric := false ;	END {while}END; {proc get_X}procedure error_msg ;BEGIN     writeln('Choose ''Ctrl-C'' to quit the program.');     readln; {clears the input if there is any left}     readln; {another ''enter'' will halt the program}     halt {goto ### }END; {proc error_msg}END. {Unit}